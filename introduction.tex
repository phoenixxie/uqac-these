%!TEX root = these.tex

\chapter{Introduction}

In this information age, a huge number of hardware and software systems have been introduced in almost every area of our life \citep{clarke1999model}. While people enjoy the facilities brought by these systems, there is sometimes the risk of failure in the systems. Some failure like some buggy computer game is annoying but tolerable, but some failure is fatal and unacceptable, e.g. the medical instruments, automated vehicle control system and aerospace system. One recent example is the Japanese astronomical satellite Hitomi which cost the Japan Aerospace Exploration Agency (JAXA) 286 million dollars. It was launched on February 17, 2016 and officially declared lost on April 28 of the same year because of a software error \citep{nature2016}.

\section{Background}

Obviously, the dependability of a system is critical, and a dependable system should have the ability to function strictly according to its specification in the stated period \citep{avivzienis2004basic}. The ability is Reliability and to measure it, some techniques are invented, one of which is model checking.

Model checking is a verification technique to automatically check the temporal states of finite systems. However, for some infinite state systems, model checking can also be utilized when combining with other techniques like program finite abstraction and model symbolic checking \citep{bultan1997symbolic}.

To apply model checking to a system, there are several common tasks \citep{clarke1999model}:
\begin{itemize}
\item Modeling is to abstract the design of a system into a model which can be acknowledged by model checking tool. For this job, it may need to ignore the insignificant detail of the design.
\item Specification is to define and specify the properties of the model. Completeness in making specification is always expected but difficult and nearly impossible.
\item Verification is to automatically verify the system states with the specification to find out the problems, but sometimes it still needs the human involvement.
\end{itemize}

For the task of Specification, Temporal Logics \citep{huth2004}, an extension of classical logic, provide a convenient language with the expressions of the properties to reason about the change of the states in terms of time, and it is applicable in many areas, some of which are verification \citep{clarke1986automatic}, monitoring \citep{basin2010policy}, data-mining \citep{van2005process}. Although there are a lot of different temporal logics invented to meet various requirements, the temporal logics are normally classified by whether the time is linear or branching. The logic with linear time is called \emph{Linear Temporal Logic} (LTL) \citep{pnueli97} and is designed to denote a consecutive sequence of states each of which has only one future state.

Researchers have proposed various solutions to resolve model checking problems with temporal logics. Some researchers introduced other mathematical method to analyze programs. \cite{esparza2001model} presented a solution to exploit regular valuations for checking LTL on pushdown systems. Some managed to take full advantage of the hardware platform. \cite{barnat2007scalable} designed a model checking tool optimized with distributed memory algorithms on multiple core systems. And because of the increasing amount of data generated, some researchers made their algorithm and solution parallelized and distributed. \cite{barre2012mapreduce} presented a parallelizable algorithm using the cloud computing framework MapReduce to process the huge amount of log data.

Bitmap is an efficient method to reduce the space overhead of data thanks to the concise structure, and the bit-level parallel and cache friendly feature is able to boost the performance of operations \citep{culpepper2010efficient}. It is widely applied in the applications which have serious demand of space and efficiency, e.g. database and search engines \citep{lemire2014}. If a bitmap is sparse, i.e. the fraction of used bits is low, the bitmap may use less storage space with the aid of the bitmap compression algorithms \citep{antoshenkov1995byte}.

In the verification of model checking, data gathering plays an important role \citep{casley1988collection}. For different systems, there are corresponding solutions of data collection. \cite{zwijze2005auditing} reviewed the data collection techniques for network analysis. \cite{calabrese2011real} presented a real-time monitoring system with high-resolution and high-definition data collection of the cellphone usage of an Italian city. \cite{shabtai2010applying} developed a host-based intrusion detection system for Android mobile devices by gathering the data of system events and user interaction. As is indicated in the examples, various mediums are utilized to retrieve and transfer data to the location where the verification takes place. Visible light is also an efficient communication medium, as is suggested in \cite{komine2004fundamental}, especially in some restricted environment where cable or radio communication are inconvenient, like \cite{vasilescu2005data}.

Various barcodes have been applied in diverse areas from traditional e-commerce systems to rapidly increasing mobile devices \citep{gao2007understanding}, for the digital barcodes provide a simple but accurate method with low cost of distribution and recognition. Compared with the well-known 1-D UPC barcode which can only encode numbers, 2-D barcodes which appeared at the end of 1980s are able to not only encode alphanumeric data and even binary data, but also supply much larger data capacity. Quick Response Code (QR code) \citep{qrcode-about} has become one of the most popular 2-D barcodes owing to its accuracy, considerable capacity, relatively small printout and high efficiency. It has been put on nearly every kind of visible surface, like paper, phone and computer screen, store windows \citep{okazaki2012benchmarking}.

\section{Thesis objectives}

The objectives of this research center around the development of methods or techniques on Model Checking which is able to give assistance to the tasks and the operations.

Bitmap has been proved by many solutions for its ability to improve the performance, and for the temporal logic states are often expressed with boolean values, i.e. true or false, Bitmap was anticipated to enhance the calculation of LTL formul\ae{}s. Therefore, one of our objectives was to find a solution of mapping temporal logic states to bits and design necessary algorithms to implement the operations of LTL. As \cite{lemire2014} suggests, a sparse bitmap is a waste of space. An additional objective was thus to observe the impact of the bitmap compression algorithms on the calculation of LTL formul\ae{}s.

Another principle objective was to develop an interesting data transfer method of data collection of Model Checking. QR Code is considered fast and large-capacity, and more important is that its utilization needs only a surface (e.g. screen) as the transmitter and a camera as the receiver, both of which have become mainstream configuration of nearly every laptop and mobile phone in recent years. If a QR code containing certain amount of data is considered as a network data packet, a sequence of QR codes is like a network data stream. Our main concern here was the bandwidth of the one-way communication channel consisting of QR Codes and the critical factors which affect the performance, and also the method of applying this communication channel to our Model Checking practice.

It is important to mention that our work and achievement of the QR Code communication channel has been published in the journal IEEE Access, vol. 4, pp. 284-298, 2016. Another part of our research, LTL Formul\ae{} with Bitmap Manipulations, is under review for publication in the proceedings of the International Conference: Runtime Verification 2016 (RV'16) in Madrid, Spain in 2016.

\section{Methodology}

This research followed a three-steps methodology.

The first step was to develop the one-way QR-Codes communication channel which corresponds to our second principle objective. The data packet was encoded to and decoded from QR codes with an open source library, and a specific protocol dedicated to the serialization and transmission of structured data over limited communication channels was introduced. As the experiment was running, we kept optimizing our solution based on the early experiment result to improve the correction rate and the recognition speed. To take well knowledge of the performance with general devices, a common webcam and a 19-inch LED monitor were used as the receiver and the transmitter in the experiment. In the last part of this step, QR codes were printed on the office papers and swiped before the webcam in order to verify a claim that the protocol can accept incoming data packet without order.

The second step had for goal to define the mapping relationship between temporal logic states and bitmap and also to design the algorithms of the temporal logic operators. The temporal sequence of states of an atomic proposition can be mapped into a bitmap where the value of each bit is either 0 or 1, which rightly corresponds to the boolean-type value of temporal logic states. We categorized the usual LTL operators defined in \cite{huth2004} into three groups: propositional logic operators, unary temporal operators and binary temporal operators. Each group had its feature and difficult, especially the binary temporal operators which have to enumerate two bitmaps together and take care of more conditions than other groups.

In the last step, we implemented our solution with a popular computer programming language. An interface of the bitmap operation was abstracted in order to adapt with the bitmap compression algorithms all of which are implemented in open source libraries. After the programming job, a throughout benchmark was made to observe the process speed without compression and also the performance of both speed and space in condition with the compress algorithms.

\section{Thesis organization}

This thesis consists of five chapters. The content of each chapter is as follows:

Chapter one introduces the background of the thesis, presents the tasks, describes the methods applied in the research and in the last states the thesis' structure.

Chapter two is one of the contributions from this research. It presents the solution of one-way communication channel consisting of flickering QR Codes. It is actually a reformatted version of the publication ``Real-Time Streaming Communication with Optical Codes'' \citep{kxie7370891}.

Chapter three is another contribution, the solution of calculating LTL formul\ae{}s with the assistance of bitmaps. The chapter details the definition of mapping, the algorithms and the experiment. It is based on the paper ``Offline Evaluation of LTL Formul√¶ with Bitmap
Manipulations'' and complimented with basic information of linear temporal logics and bitmap operations.

Chapter four discusses the methods of integrating our contributions with Model Checking systems.

Finally, chapter five concludes this research with the summary of our contributions.